<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<style>
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>
<title>Introduction of Akka Remote</title>

</head>
<body>
<h1>Introduction of Akka Remote</h1>

<p>Akka 允許遠端執行 Actor, 而且內建小型的 message server，在開發時，完全不用去理會底層網路的建置。要使用 Akka Remote 功能，要特別注意每台機器要彼此看得到。也就是說在網段的安排上，每台機器要彼此可以互連，因為 Akka Remote 會在每台機器，啟一個小 server，而且會彼此互連。</p>

<p>Akka 遠端執行，分成兩種模式如下：</p>

<h2>模式</h2>

<h3>Lookup</h3>

<p>Lookup 是在遠端 Server，先啟動 Actor，再讓 Client 連線使用。這種模式很類似傳統的 Client/Server 架構。</p>

<h3>Deployment</h3>

<p>顧名思意就是將 Local 端的 Actor，佈署到遠端的機器執行。在佈署執行環境時，還是需要將 Local 端的 Actor 放到 Remote 端。到時 Remote 端在執行時，會在自己的本機載入 Actor 來執行。</p>

<h2>Actor 基本運作</h2>

<p>在使用 Remote 功能前，先要了解 Actor 基本運作。</p>

<h3>Actor 階層關係</h3>

<p>每一個 Actor 都有一個 Supervisor，包含系統內建及自建的 Actor。如下圖：</p>

<p><img src="http://doc.akka.io/docs/akka/2.3.4/_images/guardians.png" alt="The Top-Level Supervisors" /></p>

<p><strong>Image from: <a href="http://doc.akka.io/docs/akka/2.3.4/general/supervision.html">Supervision and Monitoring</a></strong></p>

<p>我們自己產生的 Actor 會被歸類在 <code>user</code> 這一群。請特別注意 <strong>user</strong>。<strong>user</strong> 在後面的談到的 Actor Path 會利用到。</p>

<p>在容錯的機制中，Supervisor 需要扮演監控及重啟 Child Actor 的角色，Akka 本身已有內建監控與重啟的 <code>Strategy</code>。如果沒有特別去 orverride，就會套用預設的機制。</p>

<h3>Actor Path</h3>

<p>每一個 Actor 都會有一個 Actor Path，如下：</p>

<pre><code>"akka://my-sys/user/service-a/worker1"                   // purely local
"akka.tcp://my-sys@host.example.com:5678/user/service-b" // remote
</code></pre>

<p><img src="http://doc.akka.io/docs/akka/2.3.4/_images/RemoteDeployment.png" alt="The Interplay with Remote Deployment" /></p>

<p><strong>Code and image from <a href="http://doc.akka.io/docs/akka/2.3.4/general/addressing.html">Actor References, Paths and Addresses</a></strong></p>

<p>簡單來說，在單機時：</p>

<pre><code>val system = ActorSystem("HelloWorld")
val actor = system.actorOf(Props[MyActor], "MyHelloWorld")
</code></pre>

<p>上面 <code>actor</code> 的 path 會是 <code>akka://HelloWorld/user/MyHelloWorld</code> 也就是 <code>akka://System_Name/user/Actor_Name</code>，其中要特別注意 <strong>user</strong>，所以自己產生的 actor 都會被歸到 <strong>user</strong> 路徑下。</p>

<p>同理在遠端上 Actor path 就會像 <code>akka.tcp://HelloWorld@host:port/user/MyHelloWorld</code>。</p>

<p>如果某個 actor 是被另一個 actor 產生時，則 path 會像：</p>

<pre><code>akka://HelloWorld/user/parent/MyHelloWorld
</code></pre>

<p>Actor path 在系統中，是不能重覆的，因此在為 actor 命名時，要小心。</p>

<h2>實作 - 把企鵝丟到遠處</h2>

<p>延用上一篇 <strong>吃飯、睡覺、打東東</strong> 的梗，將企鵝的 Actor 放在遠端的機器上執行。<a href="https://github.com/kigichang/akka-remote-joke">Source code</a> 放在我的 GitHub 上。</p>

<h3>前置工作</h3>

<ul>
<li><p>首先要修改 <code>libraryDependencies</code> 原本是用 <code>"com.typesafe.akka" %% "akka-actor" % "2.3.4"</code> 改成 Remote 版本 <code>"com.typesafe.akka" %% "akka-remote" % "2.3.4"</code></p></li>
<li><p>在專案的目錄，新加 <code>src/main/resources</code>，並且加到 eclipse 專案的 <code>Source PATH</code>。這個目錄等一下要放設定檔。</p></li>
</ul>


<h3>Lookup 模式</h3>

<p>Lookup 模式像 Client/Server，比較好理解。先說明。</p>

<ul>
<li><p>Lookup Server</p>

<pre><code>  object LookupServer extends App {

    val system = ActorSystem("LookupServer", ConfigFactory.load("lookup-server"))

    val penguins = new Array[ActorRef](10)

    for (i &lt;- 0 to 8) {
      penguins(i) = system.actorOf(Props(classOf[Penguin], s"Penguin-$i"), s"penguin-$i")
    }

    penguins(9) = system.actorOf(Props[DongDong], "dongdong")

  }
</code></pre></li>
</ul>


<p>程式跟先前的差不多，主要差別在產生 ActorSystem 時，多了一個 <code>ConfigFactory.load("lookup-server")</code>，這個就是先前提到的設定檔，在開發環境下，會去 src/main/resources/ 目錄下找 <code>lookup-server.conf</code></p>

<ul>
<li><p>lookup-server.conf</p>

<pre><code>  akka {

    actor {
      provider = "akka.remote.RemoteActorRefProvider"
    }

    remote {
      netty.tcp {
        hostname = "127.0.0.1"
        port = 2552
      }
    }
  }
</code></pre></li>
</ul>


<p>原則上，只要寫好設定檔，在程式開好 Actor，就完成一個可以被遠端呼叫的 Server。</p>

<ul>
<li><p>Lookup Client</p>

<pre><code>  object LookupClient extends App {
    val system = ActorSystem("LookupClient", ConfigFactory.load("lookup-client"))

    val remotePath = "akka.tcp://LookupServer@127.0.0.1:2552/user/"

    val penguins = new Array[String](10)

    for (i &lt;- 0 to 8) {
      penguins(i) = remotePath + (s"penguin-$i")
    }

    penguins(9) = remotePath + "dongdong"

    val reporter = system.actorOf(Props(classOf[Reporter], penguins), "reporter")

    /* 主程式等一下，要不然上面都是 non-blocking call，會直接結束程式 */
    Thread.sleep(10000)
    system.shutdown
    println("end")
  }
</code></pre></li>
<li><p>lookup-client.conf</p>

<pre><code>  akka {
    actor {
      provider = "akka.remote.RemoteActorRefProvider"
    }

    remote {
      netty.tcp {
        hostname = "127.0.0.1"
        port = 2554
      }
    }
  }
</code></pre></li>
</ul>


<p>Client 程式，先準備好遠端 Actor Path，然後傳給 <code>Reporter</code> 去呼叫遠端的 <code>Penguin</code>。</p>

<ul>
<li><p>Reporter</p>

<pre><code>  class Reporter(var penguins: Array[String]) extends Actor {
    sendIdentifyRequest()

    def sendIdentifyRequest() {
      if (penguins != null) {
        penguins.foreach(path =&gt; context.actorSelection(path) ! Identify(path))
      }
      else {
        penguins = new Array[String](10)
        for (i &lt;- 0 to 8) {
          val actor = context.actorOf(Props(classOf[Penguin], s"Penguin-$i"))
          actor ! Identify(actor.path.toString())
          penguins(i) = actor.path.toString()
          println(actor.path)
        }

        val dong = context.actorOf(Props[DongDong])
        dong ! Identify(dong.path.toString())
        penguins(9) = dong.path.toString()
        println(dong.path)

      }
      import context.dispatcher
      context.setReceiveTimeout(5 seconds) // 設定 timeout 5 seconds
    }


    var count = 0
    def receive = {
      case ActorIdentity(path, Some(actor)) =&gt;
        count += 1
        if (count == penguins.length) {
          context.setReceiveTimeout(Duration.Undefined)
        }

        println(s"$path found")
        actor ! Interest()

      /* 有三個興趣的回覆 */
      case Three(name, a, b, c) =&gt; 
        println(s"$name: $a, $b, $c")

      /* 只有二個興趣的回覆，反問 why */      
      case Two(name, a, b) =&gt;
        println(s"$name: $a, $b")
        sender() ! Why()

      /* 接到 why 的回覆 */
      case Because(name, msg) =&gt;
        println(s"$name: $msg")
    }

    override def preStart() = {
      println("Reporter start")
    }
  }
</code></pre></li>
</ul>


<p>在 <code>Reporter</code> 中，我們使用 Actor 內建的 <code>context</code>，來查詢遠端的 actor： <code>context.actorSelection(path)</code>。</p>

<p><code>Reporter</code> 跟先前一樣，但多了一個 <code>sendIdentifyRequest</code> 的函式，主要的功能是查詢遠端的 actor 或產生 actor 送到遠端；並確定遠端的 Actor 是否已經 ready。在 Akka Actor 內建處理 <code>Identify</code> 的功能，我們可以對某個 Actor 傳送 <code>Identify</code>, <code>Identify</code> 的參數可以自定，用來辨識。當 Actor 是 OK 的話，則會收到 <code>ActorIdentity(id, Some(actor))</code>，其中的 <code>id</code> 就是先前在 <code>Identify</code> 加入的辨識字串。如果 Actor 沒有 Ready 好的話，則會收到 <code>ActorIdentity(id, None)</code>, 這時候，我們就可以知道那個 Actor 掛了。</p>

<p>執行起來的結果，你可以在 Server 的 console 上看到 <code>Penguin</code> output 的訊息，在 Client 端這邊，看到 <code>Reporter</code> 的 output。</p>

<h3>Deployment 模式</h3>

<p>Deployment 模式允許將 Local 端的 Actor 送到遠端的機器來執行。這個範例純用設定檔的方式，來佈署 Actor。Akka 也允許在程式內，自行動態佈署。</p>

<ul>
<li><p>Deploy Server - 用來執行被佈署的 Actor</p>

<pre><code>  object DeployServer extends App {
    val system = ActorSystem("DeployServer", ConfigFactory.load("deploy-server"))
  }
</code></pre></li>
</ul>


<p>由上的範例，其實我們只要啟一個 <code>ActorSystem</code> 即可。</p>

<ul>
<li><p>deploy-server.conf</p>

<pre><code>  akka {

    actor {
      provider = "akka.remote.RemoteActorRefProvider"
    }

    remote {
      netty.tcp {
        hostname = "127.0.0.1"
        port = 2551
      }
    }
  }
</code></pre></li>
</ul>


<p>其實跟上面的 <code>lookup-server.conf</code> 相似。</p>

<ul>
<li><p>deploy-client.conf</p>

<pre><code>  akka {
    actor {
      provider = "akka.remote.RemoteActorRefProvider"

      deployment {
        "/penguin/*" {
          remote = "akka.tcp://DeployServer@127.0.0.1:2551"
        }
      }
    }

    remote {
      netty.tcp {
        hostname = "127.0.0.1"
        port = 2553
      }
    }
  }
</code></pre></li>
</ul>


<p>在 client 程式前，我們先看一下 client 的 conf 檔。跟先前的 <code>lookup-client.conf</code> 差不多，但多了一個 <code>deployment</code> 設定。上面的設定，是說明要將 actor path 是 <code>/penguin/*</code> 送到遠端執行。</p>

<ul>
<li><p>Deploy Client - 將 Actor 送到 Server</p>

<pre><code>  object DeployClient extends App {
    val system = ActorSystem("DeployClient", ConfigFactory.load("deploy-client"))

    val reporter = system.actorOf(Props(classOf[Reporter], null), "penguin")

    /* 主程式等一下，要不然上面都是 non-blocking call，會直接結束程式 */
    Thread.sleep(10000)
    system.shutdown
    println("end")
  }
</code></pre></li>
</ul>


<p>我在 Client 只啟了一個 <code>Reporter</code>，且註冊 actor name 是 <code>penguin</code>，等一下我會用 <code>Reporter</code> 來產生 <code>Penguin</code> 並送到遠端的主機。</p>

<ul>
<li><p>Reporter 跟上面的 code 一樣。特別看以下這一段：</p>

<pre><code>  penguins = new Array[String](10)
  for (i &lt;- 0 to 8) {
    val actor = context.actorOf(Props(classOf[Penguin], s"Penguin-$i"))
    actor ! Identify(actor.path.toString())
    penguins(i) = actor.path.toString()
    println(actor.path)
  }

  val dong = context.actorOf(Props[DongDong])
  dong ! Identify(dong.path.toString())
  penguins(9) = dong.path.toString()
  println(dong.path)
</code></pre></li>
</ul>


<p>我用 <code>Reporter</code> 來產生 <code>Penguin</code> actor。在 <code>Actor</code> 中有 <code>context</code> 可以用來產生子 actor。由於 <code>Reporter</code> 的 actor name 是 <code>penguin</code>，這些子 <code>Penguin</code> 的 path 就會變成 <code>/penguin/xx</code>，就符合我們在 <code>deploy-client.conf</code> 設定檔上設定的 deployment 路徑 <code>/penguin/*</code>，佈署後，一樣使用 <code>Identify</code> 來確認是否完成佈署。</p>

<p>執行結果會像 lookup 模式，在 Server 端看到 <code>Penguin</code> 的 output，在 Client 端看到 <code>Reporter</code> 的 output。</p>
</body>
</html>